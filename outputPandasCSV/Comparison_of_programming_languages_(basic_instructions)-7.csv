,Unnamed: 0,variable,constant,type synonym
0,Ada[1],identifier : type« := initial_value»[e],identifier : constant type := final_value,subtype identifier is type
1,ALGOL 68,modename name« := initial_value»;,modename name = value;,mode synonym = modename;
2,C (C99),type name« = initial_value»;,enum{ name = value };,typedef type synonym;
3,Objective-C,type name« = initial_value»;,enum{ name = value };,typedef type synonym;
4,C++,type name« = initial_value»;,const type name = value;,typedef type synonym;
5,C#,"type name1« = initial_value», name2« = initial_value», ... ; or var name = initial_value;","const type name = value, name = value, ... ; or readonly type name = value, name = value, ... ;",using synonym = type;
6,D,type name« = initial_value»; or auto name = value;,const type name = value; or immutable type name = value;,alias type synonym;
7,Java,type name« = initial_value»;,final type name = value;,
8,JavaScript,var name« = initial_value»; or let name« = initial_value»; (since ECMAScript 2015),const name = value; (since ECMAScript 2015),
9,Go,var name type« = initial_value» or name := initial_value,const name «type» = value,type synonym type
10,Swift,var name« : type»« = initial_value»,let name «: type» = value,typealias synonym = type
11,Common Lisp,(defparameter name initial_value) or (defvar name initial_value) or (setf (symbol-value 'symbol) initial_value),(defconstant name value),(deftype synonym () 'type)
12,Scheme,(define name initial_value),,
13,ISLISP,(defglobal name initial_value) or (defdynamic name initial_value),(defconstant name value),
14,Pascal[a],name: type« = initial_value»,name = value,synonym = type
15,Visual Basic,Dim name «As type»,"See notes to left. Constants use the same syntax, and: use Const instead of Dim have a restriction to only certain primitive types Const name1 «As type» = value, name2 «As type» = value, ...",
16,Visual Basic .NET[10],"The variable declaration syntax of VB.NET is surprisingly difficult to precisely describe. Given that there exist the identifier suffixes (""modifiers""): type_character, available as an alternative to an As clause for some primitive data types; nullable_specifier; and array_specifier; and that a modified_identifier is of the form identifier«type_character»«nullable_specifier»«array_specifier»; a modified_identifier_list is a comma-separated list of two or more occurrences of modified_identifier; and a declarator_list is a comma-separated list of declarators, which can be of the form identifier As object_creation_expression (object initializer declarator), modified_identifier« As non_array_type«array_rank_specifier»»« = initial_value» (single declarator), or modified_identifier_list« As «non_array_type««array_rank_specifier»» (multiple declarator); valid declaration statements are of the form Dim declarator_list, where, for the purpose of semantic analysis, to convert the declarator_list to a list of only single declarators: The As clauses of each multiple declarator is distributed over its modified_identifier_list The As New type... of each object initializer declarator is replaced with As type = New type... and for which, for each identifier, a type_character and As clause do not both appear; if an As clause is present, an array_rank_specifier does not appear both as a modification of the identifier and on the type of the As clause; an unmodified_type can be determined, by the rule that, if a type_character or As clause is present, unmodified_type is that specified by such construct, and that otherwise, either Option Infer must be on and the identifier must have an initializer, in which case unmodified_type is that of the initializer, or Option Strict must be off, in which case unmodified_type is Object; its final_type is its unmodified_type prepended before its modifiers; its final_type is a valid type; and if an initial_value is present, either Option Strict is on and initial_value has a widening conversion to final_type, or Option Strict is off and initial_value has a narrowing conversion to final_type. If Option Explicit is off, variables do not require explicit declaration; they are declared implicitly when used: name = initial_value","See notes to left. Constants use the same syntax, and: use Const instead of Dim have a restriction to only certain primitive types Const name1 «As type» = value, name2 «As type» = value, ...",Imports synonym = type
17,Xojo,Dim name «As type»« = initial_value»,"See notes to left. Constants use the same syntax, and: use Const instead of Dim have a restriction to only certain primitive types Const name1 «As type» = value, name2 «As type» = value, ...",
18,Python,name = initial_value,,synonym = type[b]
19,CoffeeScript,name = initial_value,,
20,S-Lang,name = initial_value;,,typedef struct {...} typename
21,Fortran,type name,"type, PARAMETER :: name = value",
22,PHP,$name = initial_value;,"define(""name"", value); const name = value (5.3+)",
23,Perl,«my» $name« = initial_value»;[c],use constant name => value;,
24,Raku,«my «type»» $name« = initial_value»;[c],«my «type»» constant name = value;,::synonym ::= type
25,Ruby,name = initial_value,Name = value,synonym = type[b]
26,Scala,var name«: type» = initial_value,val name«: type» = value,type synonym = type
27,Windows PowerShell,«[type] »$name = initial_value,,
28,Bash shell,name=initial_value,,
29,OCaml,let name« : type ref» = ref value[d],let name «: type» = value,type synonym = type
30,F#,let mutable name« : type» = value,let name «: type» = value,type synonym = type
31,Standard ML,val name« : type ref» = ref value[d],val name «: type» = value,type synonym = type
32,Haskell,,«name::type;» name = value,type Synonym = type
33,Forth,VARIABLE name (in some systems use value VARIABLE name instead),value CONSTANT name,
34,COBOL,level-number name type clauses.,«0»1 name CONSTANT «AS» value.,level-number name type clauses «IS» TYPEDEF.
35,Mathematica,name=initial_value,,
